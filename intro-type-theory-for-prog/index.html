<!doctype html><html lang=en><head><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=utf-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
    
    Introduction to Type Theory for Programmers
    
</title><meta content=https://falfia.fi/intro-type-theory-for-prog/ property=og:url><meta content=article property=og:type><meta content="Introduction to Type Theory for Programmers" property=og:title><meta content=https://falfia.fi/icons/favicon/web-app-manifest-512x512.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=https://falfia.fi/intro-type-theory-for-prog/ property=twitter:url><meta content="Introduction to Type Theory for Programmers" name=twitter:title><meta content=https://falfia.fi/icons/favicon/web-app-manifest-512x512.png name=twitter:image><link href=https://falfia.fi/icons/favicon/favicon-96x96.png rel=icon sizes=96x96 type=image/png><link href=https://falfia.fi/icons/favicon/favicon.svg rel=icon type=image/svg+xml><link rel="shortcut icon" href=https://falfia.fi/icons/favicon/favicon.ico><link href=https://falfia.fi/icons/favicon/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><meta content="Introduction to Type Theory for Programmers" name=apple-mobile-web-app-title><link href=https://falfia.fi/icons/favicon/site.webmanifest rel=manifest><link href=https://falfia.fi/site.css rel=stylesheet><script>document.documentElement.dataset.theme =
        "light";</script><body class="hack dark main container"><header class=nav-header><nav class=navbar itemscope itemtype=http://schema.org/SiteNavigationElement><div class=nav-links><a href=https://falfia.fi itemprop=url> <span itemprop=name>Home</span> </a><a href=https://falfia.fi/categories itemprop=url> <span itemprop=name>Categories</span> </a><a href=https://falfia.fi/tags itemprop=url> <span itemprop=name>Tags</span> </a></div></nav><div class=user-actions-container><a rel="noopener noreferrer" class=feed-icon href=https://github.com/falfiya> <img alt=GitHub class=social-icon id=github-icon src=https://falfia.fi/icons/github.svg> </a></div></header><article itemscope itemtype=http://schema.org/BlogPosting><header><h1 itemprop=headline>Introduction to Type Theory for Programmers</h1><span class=muted> <svg class="icon i-clock" viewbox="0 0 32 32" fill=none height=16 stroke=currentcolor stroke-linecap=round stroke-linejoin=round stroke-width=6.25% width=16><circle cx=16 cy=16 r=14 /><path d="M16 8 L16 16 20 20"/></svg> <span>12 minute read</span> <svg class="icon i-edit" viewbox="0 0 32 32" fill=none height=16 stroke=currentcolor stroke-linecap=round stroke-linejoin=round stroke-width=6.25% width=16><path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/></svg> Published: 2025-03-22 </span></header><div itemprop=articleBody><style>html,body{overflow-x:inherit}pre code table mark{color:#fff;background-color:#c0457aab!important}table tbody td:first-child{font-weight:inherit!important}table td{vertical-align:middle}table td p{line-height:1.5em;margin:0!important}table td pre{margin:5px!important}table.center td{text-align:center}</style><p>A program can be thought of as functions. They take some input data and produce some output data. Each value has a type associated with it. <code>32.1</code> is a <code>number</code> and <code>"hello!"</code> is a <code>string</code>. Types for the same conceptual value might not be the same in every programming language. In C, C++, Java, and Python, <code>32.1</code> is a <code>float</code>. Unlike JavaScript, these languages differentiate between integers and other real numbers.<h2 id=javascript-in-n-seconds>JavaScript in 111 Seconds</h2><script>document.getElementById("javascript-in-n-seconds").innerText =
      `JavaScript in ${Math.random() * 100 + 100 | 0} Seconds`;</script><p>To get on the same page, this post is going to use JavaScript for its examples. If you already know JavaScript and TypeScript, you can <a href=https://falfia.fi/intro-type-theory-for-prog/#dynamic-typing>skip ahead</a>.<p>Here are some different types in a few programming languages:<table><tr><th><th>JavaScript<th>C/C++<th>Java<th>Python<tr><td>Real Number ($\mathbb{R}$)<td>number<td>int <p>unsigned int</p> <p>float</p> <p>double</p><td>int <p>float</p> <p>double</p><td>int <p>float</p><tr><td>String<td>string<td>char *<td>String<td>str<tr><td>Nothing<td>undefined <p>null</p><td>void<td>void<td>None</table><p>This is not an exhaustive list but it should be enough to get us up and running.<p>To get familiar with the syntax of JavaScript, I'm going to write the same functions in each of these languages:<table><tr><td><p>JavaScript</p><td><pre class=language-js data-lang=js style=color:#c0c5ce;background-color:#2b303b><code class=language-js data-lang=js><span style=color:#b48ead>function </span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#bf616a>a</span><span>, </span><span style=color:#bf616a>b</span><span>) {
</span><span>   </span><span style=color:#b48ead>return </span><span>(</span><span style=color:#bf616a>a </span><span>+ </span><span style=color:#bf616a>b</span><span>) / </span><span style=color:#d08770>2</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>function </span><span style=color:#8fa1b3>exclaim</span><span>(</span><span style=color:#bf616a>s</span><span>) {
</span><span>   </span><span style=color:#b48ead>return </span><span style=color:#bf616a>s </span><span>+ "</span><span style=color:#a3be8c>!</span><span>";
</span><span>}
</span></code></pre><tr><td><p>TypeScript</p><td><pre class=language-ts data-lang=ts style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><span style=color:#b48ead>function </span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#bf616a>a</span><span>: number, </span><span style=color:#bf616a>b</span><span>: number): number {
</span><span>   </span><span style=color:#b48ead>return </span><span>(</span><span style=color:#bf616a>a </span><span>+ </span><span style=color:#bf616a>b</span><span>) / </span><span style=color:#d08770>2</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>function </span><span style=color:#8fa1b3>exclaim</span><span>(</span><span style=color:#bf616a>s</span><span>: string): string {
</span><span>   </span><span style=color:#b48ead>return </span><span style=color:#bf616a>s </span><span>+ "</span><span style=color:#a3be8c>!</span><span>";
</span><span>}
</span></code></pre><tr><td><p>C / C++</p><td><pre class=language-cxx data-lang=cxx style=color:#c0c5ce;background-color:#2b303b><code class=language-cxx data-lang=cxx><span style=color:#b48ead>float </span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#b48ead>float </span><span style=color:#bf616a>a</span><span>, </span><span style=color:#b48ead>float </span><span style=color:#bf616a>b</span><span>) {
</span><span>   </span><span style=color:#b48ead>return </span><span>(a + b) / </span><span style=color:#d08770>2</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>char </span><span>*</span><span style=color:#8fa1b3>exclaim</span><span>(</span><span style=color:#b48ead>char const </span><span>*</span><span style=color:#bf616a>s</span><span>) {
</span><span>   size_t old_len = </span><span style=color:#96b5b4>strlen</span><span>(s);
</span><span>   size_t new_len = old_len + </span><span style=color:#d08770>1</span><span>;
</span><span>   </span><span style=color:#b48ead>char </span><span>*out = </span><span style=color:#96b5b4>malloc</span><span>(new_len + </span><span style=color:#d08770>1</span><span>); </span><span style=color:#65737e>// +1 for '\0'
</span><span>   </span><span style=color:#96b5b4>memcpy</span><span>(out, s, old_len);
</span><span>   out[old_len] = '</span><span style=color:#a3be8c>!</span><span>';
</span><span>   out[new_len] = '</span><span style=color:#96b5b4>\0</span><span>';
</span><span>   </span><span style=color:#b48ead>return</span><span> out;
</span><span>}
</span></code></pre><tr><td><p>Java</p><td><pre class=language-java data-lang=java style=color:#c0c5ce;background-color:#2b303b><code class=language-java data-lang=java><span style=color:#b48ead>float </span><span style=color:#bf616a>average</span><span>(</span><span style=color:#b48ead>float</span><span> a, </span><span style=color:#b48ead>float</span><span> b) {
</span><span>   </span><span style=color:#b48ead>return </span><span>(a + b) / </span><span style=color:#d08770>2</span><span>;
</span><span>}
</span><span>
</span><span style=color:#ebcb8b>String </span><span style=color:#bf616a>exclaim</span><span>(</span><span style=color:#ebcb8b>String</span><span> s) {
</span><span>   </span><span style=color:#b48ead>return</span><span> s + "</span><span style=color:#a3be8c>!</span><span>";
</span><span>}
</span></code></pre><tr><td><p>Python</p><td><pre class=language-py data-lang=py style=color:#c0c5ce;background-color:#2b303b><code class=language-py data-lang=py><span style=color:#b48ead>def </span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#bf616a>a</span><span>, </span><span style=color:#bf616a>b</span><span>):
</span><span>   </span><span style=color:#b48ead>return </span><span>(a + b) / </span><span style=color:#d08770>2
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>exclaim</span><span>(</span><span style=color:#bf616a>s</span><span>: str) -> str:
</span><span>   </span><span style=color:#b48ead>return </span><span>s + "</span><span style=color:#a3be8c>!</span><span>"
</span></code></pre></table><p>Besides the C one that took some memory finagling, they all more or less look the same. There are two things of note:<ol><li>The TypeScript is almost identical to the the JavaScript. The only difference is types attached using <code>: type</code>.<li>The Python program has types listed for <code>exclaim</code> but not <code>average</code>. That's because <code>average(a: int, b: int) -> float</code> wouldn't quite be accurate. <code>a</code> and <code>b</code> can be either <code>int</code> <em>or</em> <code>float</code><sup class=footnote-reference><a href=#1>1</a></sup>.</ol><p>The rest of this post will use JavaScript (and eventually TypeScript). We won't use advanced syntax in this post.<h2 id=dynamic-typing>Dynamic Typing</h2><p>In dynamically typed languages like JavaScript and Python, you don't always know the type of a variable when you're writing the code.<p>Let's look at an example program in JavaScript:<pre class=language-js data-lang=js style=color:#c0c5ce;background-color:#2b303b><code class=language-js data-lang=js><span style=color:#b48ead>function </span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#bf616a>a</span><span>, </span><span style=color:#bf616a>b</span><span>) {
</span><span>   </span><span style=color:#b48ead>return </span><span>(</span><span style=color:#bf616a>a </span><span>+ </span><span style=color:#bf616a>b</span><span>) / </span><span style=color:#d08770>2</span><span>;
</span><span>}
</span></code></pre><p>I can call this function in several different ways:<pre class=language-js data-lang=js style=color:#c0c5ce;background-color:#2b303b><code class=language-js data-lang=js><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#d08770>4</span><span>, </span><span style=color:#d08770>2</span><span>);         </span><span style=color:#b48ead>=> </span><span style=color:#d08770>3
</span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#d08770>5.5</span><span>, </span><span style=color:#d08770>4.5</span><span>);     </span><span style=color:#b48ead>=> </span><span style=color:#d08770>5
</span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#d08770>4</span><span>, "</span><span style=color:#a3be8c>2</span><span>");       </span><span style=color:#b48ead>=> </span><span style=color:#d08770>21
</span><span style=color:#8fa1b3>average</span><span>("</span><span style=color:#a3be8c>uh</span><span>", "</span><span style=color:#a3be8c>oh</span><span>");   </span><span style=color:#b48ead>=> </span><span style=color:#d08770>NaN
</span></code></pre><p>Depending on the types of the arguments, something <em>very</em> different happens. Particularly on lines 3 and 4. In JavaScript, when you add two numbers, you get another number. But when you add two strings, you get another string. Additionally, anything plus a string gets you another string. People call this behavior <em>weak-typing</em><sup class=footnote-reference><a href=#2>2</a></sup>.<pre class=language-js data-lang=js style=color:#c0c5ce;background-color:#2b303b><code class=language-js data-lang=js><span> </span><span style=color:#d08770>1   </span><span>+  </span><span style=color:#d08770>2  </span><span>== </span><span style=color:#d08770>3
</span><span>"</span><span style=color:#a3be8c>1</span><span>"  + "</span><span style=color:#a3be8c>2</span><span>" == "</span><span style=color:#a3be8c>12</span><span>"
</span><span> </span><span style=color:#d08770>1   </span><span>+ "</span><span style=color:#a3be8c>2</span><span>" == "</span><span style=color:#a3be8c>12</span><span>"
</span><span style=color:#d08770>null </span><span>+ "</span><span style=color:#a3be8c>y</span><span>" == "</span><span style=color:#a3be8c>nully</span><span>"
</span></code></pre><h2 id=graduating-to-static-typing>Graduating to Static Typing</h2><p>We can do better. Let's switch to TypeScript and start adding types to our arguments. We'd like to prohibit inputs that make the function behave strangely.<pre class=language-ts data-lang=ts data-linenos style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><table><tbody><tr><td>1<td><span style=color:#b48ead>function </span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#bf616a>a</span><span>: number, </span><span style=color:#bf616a>b</span><span>: number): number {
</span><tr><td>2<td><span>   </span><span style=color:#b48ead>return </span><span>(</span><span style=color:#bf616a>a </span><span>+ </span><span style=color:#bf616a>b</span><span>) / </span><span style=color:#d08770>2</span><span>;
</span><tr><td>3<td><span>}
</span><tr><td>4<td><span>
</span><tr><td><mark style=background-color:#65737e30>5</mark><td><mark style=background-color:#65737e30><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#d08770>4</span><span>, "</span><span style=color:#a3be8c>2</span><span>");
</span></mark><tr><td><mark style=background-color:#65737e30>6</mark><td><mark style=background-color:#65737e30><span style=color:#8fa1b3>average</span><span>("</span><span style=color:#a3be8c>uh</span><span>", "</span><span style=color:#a3be8c>oh</span><span>");
</span></mark></table></code></pre><blockquote><p>Argument of type 'string' is not assignable to parameter of type 'number'.</blockquote><p>As desired. In this case, we used types to constrain the function domain, thereby shrinking the program execution space to something more representative of "average". A smaller execution space is easier to reason about.<p>With static typing, we can catch rare bugs:<pre class=language-ts data-lang=ts data-linenos style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><table><tbody><tr><td>1<td><span style=color:#b48ead>let </span><span style=color:#bf616a>x</span><span>;
</span><tr><td>2<td><span style=color:#b48ead>if </span><span>(Math.</span><span style=color:#96b5b4>random</span><span>() > </span><span style=color:#d08770>0.001</span><span>) {
</span><tr><td>3<td><span>   </span><span style=color:#bf616a>x </span><span>= </span><span style=color:#8fa1b3>average</span><span>(</span><span style=color:#d08770>9</span><span>, </span><span style=color:#d08770>9</span><span>);
</span><tr><td>4<td><span>} </span><span style=color:#b48ead>else </span><span>{
</span><tr><td>5<td><span>   </span><span style=color:#65737e>// very rare!
</span><tr><td>6<td><span>   </span><span style=color:#65737e>// compiler catches the bug anyways
</span><tr><td><mark style=background-color:#65737e30>7</mark><td><mark style=background-color:#65737e30><span>   </span><span style=color:#bf616a>x </span><span>= </span><span style=color:#8fa1b3>average</span><span>("</span><span style=color:#a3be8c>9</span><span>", </span><span style=color:#d08770>9</span><span>);
</span></mark><tr><td>8<td><span>}
</span></table></code></pre><h2 id=easing-into-math>Easing Into Math</h2><p>Our next code sample is rather contrived:<pre class=language-ts data-lang=ts data-linenos style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><table><tbody><tr><td>1<td><span style=color:#b48ead>function </span><span style=color:#8fa1b3>times_two</span><span>(</span><span style=color:#bf616a>x</span><span>: number): number {
</span><tr><td>2<td><span>   </span><span style=color:#b48ead>const </span><span style=color:#bf616a>y </span><span>= Math.</span><span style=color:#96b5b4>floor</span><span>(</span><span style=color:#bf616a>x</span><span>) * </span><span style=color:#d08770>2</span><span>;
</span><tr><td>3<td><span>   </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>y </span><span>% </span><span style=color:#d08770>2 </span><span>=== </span><span style=color:#d08770>0</span><span>) {
</span><tr><td>4<td><span>      </span><span style=color:#b48ead>return </span><span style=color:#bf616a>y</span><span>;
</span><tr><td>5<td><span>   }
</span><tr><td>6<td><span>
</span><tr><td><mark style=background-color:#65737e30>7</mark><td><mark style=background-color:#65737e30><span>   </span><span style=color:#65737e>//return
</span></mark><tr><td>8<td><span>}
</span></table></code></pre><blockquote><p>Function lacks ending return statement and return type does not include 'undefined'</blockquote><p>We, as humans, know that <code>y</code> is always an integer multiple of 2. <code>y</code> modulo 2 must be 0. Unfortunately, TypeScript isn't that clever yet.<p>Let's try and talk about that in a more mathematical way. The primary motivation for math in this case is terseness, formality, and precision. To do that, we'll need to briefly cover logic and set theory. If you know these, you can <a href=https://falfia.fi/intro-type-theory-for-prog/#average.ts-explanation>skip ahead</a>.<ul><li>Logical Connectives <ul><li>Not: $\neg$<li>And: $\land$<li>Or: $\lor$</ul><li>Quantifiers <ul><li>Exists: $\exists$<li>For All: $\forall$</ul><li>Misc <ul><li>Such That: $\text{st}$ or $\ni:$<li>Therefore: $\therefore$</ul></ul><p>Sets are pretty great. They're similar to arrays or lists in that they contain elements, but a set cannot have duplicate elements. A value is either in a set or it isn't. Unlike a list, the order of elements within a set does not matter.<p>A set is written using braces. The following are sets containing only 1, 2, and 3 and they are all equivalent:<ul><li>$\{1, 2, 3\}$<li>$\{1, 2, 3, 1\}$<li>$\{3, 2, 1\}$</ul><p>To write "<code>a</code> is an element of <code>A</code>", we write $a\,\in\,A$.</p><center> <p>$$ \begin{array}{rcllr} 1&\in &\{1, 2, 3\}& \quad& \text{True}\\ 4&\in &\{1, 2, 3\}& &\text{False}\\ 4&\cancel{\in} &\{1, 2, 3\}&& \text{True}\\ \end{array} $$</p> </center><p>You can also construct sets using other sets. The syntax is $\{\textit{value}\,|\,\textit{conditional}\}$. For example:<p>$$ \begin{align} \text{let}\,A &= \{1, 2, 3\} \\ B &= \{2 * a\,|\,a\in A\} \\ B &= \{2, 4, 6\} \end{align} $$<p>There are also some common set names:<ul><li>Empty Set: $\text{Ø}$<li>Real Numbers: $\mathbb{R}$<li>Integers: $\mathbb{Z}$<li>Positive Integers (Natural Numbers): $\mathbb{N}^+$</ul><p><a name=average.ts-explanation></a><table><tr><td>TypeScript<td>Math<td>English<tr><td><pre class=language-ts data-lang=ts style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><span style=color:#b48ead>function </span><span style=color:#8fa1b3>times_two</span><span>(</span><span style=color:#bf616a>x</span><span>: number)
</span></code></pre><td>$$ x \in \mathbb{R} $$<td><p><code>x</code> is <em>some</em> real number.</p><tr><td rowspan=2><pre class=language-ts data-lang=ts style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><span>   </span><span style=color:#b48ead>const </span><span style=color:#bf616a>y </span><span>= Math.</span><span style=color:#96b5b4>floor</span><span>(</span><span style=color:#bf616a>x</span><span>) * </span><span style=color:#d08770>2</span><span>;
</span></code></pre><td>$$ y = 2 * \text{floor}(x) $$<td><p><code>y</code> is 2 times the floor of <code>x</code>.</p><tr><td><p>$$ y \in \{2a\,|\,a \in \mathbb{Z}\} $$</p><td><p><code>y</code> is an integer multiple of 2.</p><tr><td><pre class=language-ts data-lang=ts style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><span>   </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>y </span><span>% </span><span style=color:#d08770>2 </span><span>=== </span><span style=color:#d08770>0</span><span>) {
</span><span>      </span><span style=color:#b48ead>return </span><span style=color:#bf616a>y</span><span>;
</span><span>   }
</span></code></pre><td><p>$$ \therefore mod(y, 2) = 0 $$</p><td><p>Therefore, <code>y</code> modulo 2 is 0. The conditional is always true and <code>y</code> is returned.</p></table><p>Was this argument convincing? I think it was. But there's a huge problem: we had to use our brain. Brains can make mistakes and can be convinced of things that are untrue so this proof is ungood.<h2 id=assembling-a-type-theory>Assembling a Type Theory</h2><p>It'd be just great if we could mechanize this process. Once again, I will introduce more notation<sup class=footnote-reference><a href=#3>3</a></sup>:<p>$$ \frac{\textit{Premise}_1\quad...\quad\textit{Premise}_n}{\textit{Conclusion}}\textit{Name} $$<p>This is no fraction! This is an inference rule. Let's look at a few examples:<table><tr><td><p>$$ \frac{\text{Raining}}{\text{Wet In My Garden}} $$</p><td><p>$$ \frac{\text{Sprinklers On}}{\text{Wet In My Garden}} $$</p><tr><td colspan=2><p>$$ \frac{\text{Flowers in My Garden} \quad \text{Wet In My Garden}}{\text{Flowers Watered}} $$</p></table><p>From these rules, I can prove that if it is raining <strong>and</strong> I have flowers in my garden, then my flowers are watered.<p>$$ \frac{\dfrac{\text{Raining}}{\text{Wet In My Garden}}\quad\text{Flowers in My Garden}}{\text{Flowers Watered}} $$<p>Also, if we can prove something without a premise, we simply omit the premises entirely:<p>$$ \frac{}{\text{Types Are Wonderful!}} $$<p>Fun, right? Let's get some type theory going by writing inference rules for the JavaScript <code>+</code> operator.<p>First, recursively define JavaScript expressions and create notation:<ul><li>$n$ is any $\mathbb{R}$<li>$s$ is any <code>string</code><li>$e$ is an expression, which is one of: <ul><li>$n$<li>$s$<li>$e_1 + e_2$</ul></ul><p>Subscripting any of these just distinguishes them. $n_1$ and $n_2$ are both Reals, but not necessarily the same one.<p>Here are some JavaScript expressions written out in symbols:<table><tr><td><p>$$ [s] $$</p><td><p>$$ [e_1 + s] $$</p><td><p>$$ [n + e_1 + s] $$</p><td><p>$$ [e_2 + e_1 + n + n] $$</p></table><p>For clarity, let's always use brackets around the whole expression.<p>Next, let's define our types.<ul><li>$\diamond$ (diamond)<li>$\omega$ (omega)<li>$\tau$ (tau) is a type, which is one of: <ul><li>$\diamond$<li>$\omega$</ul></ul><p>Now, I'm not going to tell you what $\diamond$ and $\omega$ are but I will show you how they're used.<table><tr><td><p>$$ \frac{}{[n] : \diamond} $$</p><td><p>$$ \frac{}{[s] : \omega} $$</p><td><p>$$ \frac{[e_1] : \diamond \quad [e_2] : \diamond}{[e_1 + e_2] : \diamond} $$</p><tr><td><p>$$ \frac{[e_1] : \omega \quad [e_2] : \diamond}{[e_1 + e_2] : \omega} $$</p><td><p>$$ \frac{[e_1] : \diamond \quad [e_2] : \omega}{[e_1 + e_2] : \omega} $$</p><td><p>$$ \frac{[e_1] : \omega \quad [e_2] : \omega}{[e_1 + e_2] : \omega} $$</p></table><p>Recall the rules of the JavaScript <code>+</code> operator:<pre class=language-ts data-lang=ts style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><span style=color:#bf616a>number </span><span>+ </span><span style=color:#bf616a>number </span><span style=color:#b48ead>=> </span><span style=color:#bf616a>number
</span><span style=color:#bf616a>string </span><span>+ </span><span style=color:#bf616a>any    </span><span style=color:#b48ead>=> </span><span style=color:#bf616a>string
</span><span style=color:#bf616a>any    </span><span>+ </span><span style=color:#bf616a>string </span><span style=color:#b48ead>=> </span><span style=color:#bf616a>string
</span></code></pre><p>Try to understand the notation and guess what $\diamond$ and $\omega$ mean. Then open the answer below.<details><summary>Answer</summary> <p>When I write $[e] : \tau$, read "the JavaScript expression $e$ has type $\tau$".</p> <ul><li>$\diamond$ is for numbers<li>$\omega$ is for strings</ul> <p>These are not sets. They are simply symbols that we'll attach to JavaScript expressions using the colon.</p> <table class=center><tr><td>Type Theory<td>English<tr><td>$$ \frac{e_1 : \diamond \quad e_2 : \omega}{[e_1 + e_2] : \omega} $$<td><p>If the type of $e_1$ is <code>number</code> and the type of $e_2$ is <code>string</code>,</p> <p>then the type of $e_1 + e_2$ is <code>string</code>.</p></table></details><h2 id=functions-variables-and-context-oh-my>Functions, Variables, and Context! Oh My!</h2><p>What about functions and variables? For those, we will have to extend both the JavaScript expression grammar and the type grammar:<ul><li>$n$ is any $\mathbb{R}$<li>$s$ is any <code>string</code><li>$v$ is a variable, which is one of: ‼️ <ul><li>$x$<li>$y$<li>$z$</ul><li>$e$ is an expression, which is one of: <ul><li>$n$<li>$s$<li>$v$<li>$e_1 + e_2$<li>$v \Rightarrow e$ is a lambda‼️<li>$e_1(e_2)$ is a lambda call‼️</ul><li>$\diamond$ is any <code>number</code><li>$\omega$ is any <code>string</code><li>$\tau$ is a type, which is one of: <ul><li>$\diamond$<li>$\omega$<li>$\tau_1 \rightarrow \tau_2$ is a function from $\tau_1$ to $\tau_2$‼️</ul></ul><p>"Wait, where are the functions I was promised?", you ask.<p>Instead of functions, we're going to have lambdas<sup class=footnote-reference><a href=#4>4</a></sup>. They work like so: $\textit{Parameter Name} \Rightarrow \textit{Return Expression}$<pre class=language-ts data-lang=ts style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><span style=color:#b48ead>function </span><span style=color:#8fa1b3>add_three</span><span>(</span><span style=color:#bf616a>a</span><span>) {
</span><span>   </span><span style=color:#b48ead>return </span><span style=color:#bf616a>a </span><span>+ </span><span style=color:#d08770>3</span><span>;
</span><span>}
</span><span>
</span><span style=color:#65737e>// equivalent
</span><span>
</span><span style=color:#8fa1b3>add_three </span><span>= </span><span style=color:#bf616a>a </span><span style=color:#b48ead>=> </span><span style=color:#bf616a>a </span><span>+ </span><span style=color:#d08770>3</span><span>;
</span></code></pre><p>Now consider the following program:<p>$$ [(x \Rightarrow x + 1)(2) + (x \Rightarrow x + 1)(\textcolor{green}{\texttt{"2"}})] $$<p>What is the type of $[x + 1]$? Well, that depends on the context, doesn't it?<table><tr><td><p>$$ \frac{[x] : \diamond}{[x + 1] : \diamond} $$</p><td><p>$$ \frac{[x] : \omega}{[x + 1] : \omega} $$</p></table><p>But this notation only allows us to have <em>one</em> type for $x$. We'll have to think differently now.<p>Introducing $\Gamma$ (Gamma), the type context! Think of it like a dictionary of resolved types for variables<sup class=footnote-reference><a href=#6>5</a></sup>.<pre class=language-ts data-lang=ts style=color:#c0c5ce;background-color:#2b303b><code class=language-ts data-lang=ts><span style=color:#bf616a>Γ </span><span>= {v1: </span><span style=color:#bf616a>𝜏1</span><span>, v2: </span><span style=color:#bf616a>𝜏2</span><span>, ...};
</span></code></pre><p>When I write $\Gamma \vdash [x] : \tau$, read "In a certain context $\Gamma$, $x$ has type $\tau$"<sup class=footnote-reference><a href=#5>6</a></sup>.<table><tr><td><p>Using this new notation, I can stuff type judgements like "$x$ has type $\tau$" into $\Gamma$.</p><td><p>$$ \frac{}{\Gamma \vdash [x] : \tau} $$</p><tr><td><p>And I can <em>"query"</em> $\Gamma$ for "$y$ has type $\diamond$" and conditionally do something if it exists.</p><td>$$ \frac{\Gamma \vdash [y]: \diamond}{\text{Something}} $$</table><p>Let's update our inference rules.<table><tr><td><p>$$ \frac{}{[n] : \diamond} $$</p><td><p>$$ \frac{}{[s] : \omega} $$</p><td><p>$$ \frac{\Gamma \vdash [e_1] : \diamond \qquad\Gamma \vdash [e_2] : \diamond}{\Gamma \vdash [e_1 + e_2] : \diamond} $$</p><tr><td><p>$$ \frac{\Gamma \vdash [e_1] : \tau \qquad\Gamma \vdash [e_2] : \omega}{\Gamma \vdash [e_1 + e_2] : \omega} $$</p><td><p>$$ \frac{\Gamma \vdash [e_1] : \omega \qquad\Gamma \vdash [e_2] : \tau}{\Gamma \vdash [e_1 + e_2] : \omega} $$</p><td>‼️ $$ \frac{\Gamma \\,[v] : \tau_1 \vdash [e] : \tau_2}{\Gamma \vdash [v \Rightarrow e] : \tau_1 \rightarrow \tau_2} $$<tr><td colspan=2>‼️ $$ \frac{\Gamma \vdash [e_1] : \tau_1 \rightarrow \tau_2 \qquad \Gamma \vdash [e_2] : \tau_1}{\Gamma \vdash [e_1(e_2)] : \tau_2} $$</table><p>There are two brand new rules. I would encourage you to try and work them out on your own and then check your understanding below.<details><summary>The Last Two Rules</summary> <table class=center><tr><td>Type Theory<td>English<tr><td>$$ \frac{\Gamma \\,[\textcolor{teal}{v}] : \textcolor{blue}{\tau_1} \vdash [\textcolor{magenta}{e}] : \textcolor{purple}{\tau_2}}{\Gamma \vdash [\textcolor{teal}{v} \Rightarrow \textcolor{magenta}{e}] : \textcolor{blue}{\tau_1} \rightarrow \textcolor{purple}{\tau_2}} $$<td><p>This one makes more sense if we have an actual example. Let us instantiate $v$ and $e$:</p> <p>$$ \textcolor{teal}{v} = x\qquad \textcolor{magenta}{e}=[\textcolor{teal}{x} + 1] $$</p> <p>Hypothetically, if we add the typing judgement $\textcolor{teal}{x} : \textcolor{blue}{\diamond}$ to the context $\Gamma$, that causes $\textcolor{magenta}{x + 1}$ to have type $\textcolor{purple}{\diamond}$.</p> <p>Because of that, a function whose parameter is $\textcolor{teal}{x}$ and returns $\textcolor{magenta}{x + 1}$ has the type $\textcolor{blue}{\diamond} \rightarrow \textcolor{purple}{\diamond}$</p><tr><td>$$ \frac{\Gamma \vdash [e_1] : \tau_1 \rightarrow \tau_2 \qquad \Gamma \vdash [e_2] : \tau_1}{\Gamma \vdash [e_1(e_2)] : \tau_2} $$<td><p>If you have a function $e_1$ that takes $\tau_1$ and returns $\tau_2$, then calling it with an argument $e_2$ of type $\tau_1$ gets you $\tau_2$.</p></table></details><p>Thank you for reading and happy typing!<p><em>I;m Thinking About Thos Types :)</em><h2 id=citations>Citations</h2><ol><li>F. Shinko, Introduction to type theory. [Online]. Available: https://math.berkeley.edu/~forte/notes/type_theory.pdf. Accessed: Mar. 12, 2025.<li>H. Geuvers, Introduction to Type Theory. [Online]. Available: https://www.cs.ru.nl/~herman/onderwijs/provingwithCA/paper-lncs.pdf. Accessed: Mar. 13, 2025.<li>B. C. Pierce, Types and Programming Languages Cambridge, MA, USA: MIT Press, 2002.</ol><h2 id=footnotes>Footnotes</h2><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p><code>int | float</code> is a valid way to write that, but I didn't want to introduce union types just yet.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>People call things <em>weakly-typed</em> when they don't like what happens.</div><div class=footnote-definition id=3><sup class=footnote-definition-label>3</sup><p>This notation is called "Gentzen-style Natural Deduction"</div><div class=footnote-definition id=4><sup class=footnote-definition-label>4</sup><p>Praise Church. Search up "Lambda Calculus" if you want to learn more.</div><div class=footnote-definition id=5><sup class=footnote-definition-label>6</sup><p>$\Gamma \vdash ...$ is actually the same thing as $\frac{\Gamma}{...}$, but that would be too confusing to explain inline.</div><div class=footnote-definition id=6><sup class=footnote-definition-label>5</sup><p>This is a half-truth, only useful insofar as it helps intuition.</div></div><footer><hr><p>in <a href=https://falfia.fi/categories/tutorial/>tutorial</a> and tagged <a href=https://falfia.fi/tags/math/>math</a> , <a href=https://falfia.fi/tags/type-theory/>type theory</a> and <a href=https://falfia.fi/tags/computer-science/>computer science</a></footer></article><script src=https://falfia.fi/js/toggle-theme.js></script><script src=https://falfia.fi/js/mathjax-config.js></script><script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>